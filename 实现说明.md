# 实现说明

## 程序运行流程

1. **命令行处理（`main`）**：解析 `--help`、`--verbose_mode` 等参数，决定是否启用详细输出或输出使用指南。
2. **Makefile 预处理（`process_makefile`）**：按行依次读取 `Makefile`，移除注释与尾部空白，保存在数组中；可选地将净化结果写入 `Minimake_cleared.mk`。
3. **语法校验（`grammar_check`）**：按行类型检测目标/命令/变量定义/空行/注释的排列是否合法，提前阻断格式错误。变量定义行（`NAME = VALUE`）被允许并跳过错误检查。
4. **变量解析与替换（`parse_var_replace` + `parse_makefile`）**：
	- 初始化变量系统（`var_init`）。
	- 解析变量定义行：提取 `NAME` 与 `VALUE`，先对 `VALUE` 做变量展开，再 `var_set` 存储（支持覆盖）。
	- 解析目标与依赖/命令时：对文本进行变量展开（`var_expand_into`）。依赖项会在“展开后”再次按空白切分，从 `$(SRC) -> a.o b.o` 得到两个独立依赖。
	- 在解析结束后，可将变量导出到环境（`var_export_to_env`），便于 shell 中以 `$NAME` 形式使用。
5. **目标与依赖解析（`parse_makefile`）**：将预处理后的文本拆分成多个 `Target_block`，记录目标名、依赖列表与命令序列，并进行重复目标与依赖有效性检查。
6. **依赖图构建（`build_dep_graph`）**：将目标及其依赖映射为有向图节点，维护入度信息并输出拓扑排序结果。
7. **拓扑排序（`topo_sort_graph`）**：使用 Kahn 算法确定合法的构建顺序，检测并报告是否有依赖环。
8. **构建（`perform_builds`）**：沿拓扑序遍历，借助 `target_need_build` 判定是否需要重建目标；对需要执行的目标调用 `execute_target_commands`，由 `run_single_command` 逐条执行 shell 命令。

## 源码模块与函数职责

### `src/main.c`
- `main`：程序入口。解析命令行参数、执行预处理、语法检查、解析目标块、构建依赖图、拓扑排序，并按照依赖顺序触发构建。

### `src/preprocess.c`
- `trim_trailing_whitespace`：去除字符串末尾的空白字符。
- `remove_comments`：截断行中 `#` 之后的注释内容。
- `is_empty_line`：判断一行是否仅包含空白符。
- `process_makefile`：读取 `Makefile`，依次执行清理、过滤，保存结果到内存数组，并在详细模式下输出净化后的文件。

### `src/grammar_check.c`
- `line_type_judge`：判定一行文本的类型（目标、命令、变量定义、空行、注释或非法）。
- `target_line_check`：检测行是否符合目标定义格式（包含冒号且首字符不为空白）。
- `grammar_check`：对预处理结果进行整体语法校验，确保命令前有目标、命令行以制表符开头等规则；变量定义行允许出现在目标规则之前或之间，不视为错误。

### `src/parse.c`
- `parse_target_line`：解析目标行，提取目标名称与依赖列表。
- `parse_cmd_line`：清洗命令行并追加到目标块的命令数组。
- `parse_makefile`：
	- 遍历预处理后的文本，根据行类型拆分成 `Target_block` 数组；
	- 遇到变量定义行（`NAME = VALUE`）时：先展开右值，再写入变量表（覆盖同名变量）；
	- 解析目标/依赖/命令时，对文本做变量展开；依赖在展开后进行二次按空白切分；
	- 输出解析结果。
- `print_target_blocks`：调试辅助函数，打印所有目标块的结构化信息。
- `has_duplicate_target`：检查是否存在重复的目标定义。
- `is_dep_invaild`：验证依赖项是否在其他目标中声明或存在于文件系统。
- `parse_check`：综合调用上述校验函数，确认依赖与目标定义的合法性。

### `src/graph.c`
- `graph_find_node`：在依赖图中查找指定名称的节点索引。
- `build_dep_graph`：根据目标块建立依赖图节点及 `dep -> target` 边；统计入度信息。
- `topo_sort_graph`：使用 Kahn 算法执行拓扑排序，检测依赖环并打印排序结果。
- `collect_needed_nodes`：基于逆向 DFS 收集某个目标所需的全部节点，用于按需构建。
- `print_graph`：打印依赖图的节点与边信息。
- （静态辅助）`add_node`、`reverse_dfs`：内部使用，负责新增节点与逆向遍历。

### `src/build.c`
- `target_need_build`：判断目标是否需要重新构建，综合考虑目标是否存在及依赖文件的时间戳。
- `perform_builds`：按拓扑顺序遍历节点，对需要更新的目标执行命令，输出构建状态。
- （静态辅助）`find_target_block`：根据名称查找目标块索引。

### `src/execute_cmd.c`
- `execute_target_commands`：顺序执行目标块内的命令列表，遇到失败立即停止。
- （静态辅助）`run_single_command`：负责使用 `/bin/sh -c` 执行单条 shell 命令，并解析子进程的退出状态。

### `src/parse_var_replace.c`
- 提供 Makefile 风格变量的存储、查询与递归展开：
	- `var_init`：初始化变量表；
	- `var_set`：设置/覆盖变量（后定义覆盖先定义）；
	- `var_get`：读取变量，若未定义则回退到 `getenv`，仍无则为空串；
	- `var_expand_into`：对字符串中的 `$(NAME)`/`${NAME}` 进行递归展开，支持 `$$ -> $` 转义；
	- `var_export_to_env`：将内部变量导出到进程环境，便于 shell 使用 `$NAME`。

#### 变量展开与边界策略
- 递归展开深度限制为 16 层，防止循环引用（如 `A=$(B)` 与 `B=$(A)`）。
- 未定义变量：替换为空串（静默处理）。
- 依赖解析：对依赖 token 展开后再次按空白切分，确保 `$(SRC)` 可展开为多个独立依赖。
- 安全性：所有写入都保证以 `\0` 结尾，可能发生截断但不越界。

### 头文件 (`include/`)
- `common.h`：全局常量定义，如行/依赖数限制、图节点上限等。
- `preprocess.h`、`grammar_check.h`、`parse.h`、`graph.h`、`build.h`、`execute_cmd.h`：分别声明对应模块的公开接口与核心数据结构，供其它源文件引用。
- `parse_var_replace.h`：变量模块对外接口声明，与 `src/parse_var_replace.c` 配套使用。

### `test/`
- `Makefile`、`main.c`、`libutil.c` 等：提供测试或示例使用场景，可用于验证解析与构建流程。


