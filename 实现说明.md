# 实现说明

## 总览

- 主要模块
  - 预处理：`src/preprocess.c`
  - 语法检查：`src/grammar_check.c`
  - 变量系统与替换：`src/parse_var_replace.c`
  - 解析 Makefile：`src/parse.c`
  - 依赖图：`src/graph.c`
  - 构建调度与并行执行：`src/build.c`、`src/execute_cmd.c`
  - CLI 参数解析：`src/clioptions_parse.c`

## 运行流程（main）

1. 变量系统初始化：`var_init()`
2. 解析命令行：`parse_args()`
   - 选项：`-h/--help`、`-v/--verbose_mode`、`-j N` 或 `-jN`或`-jod N`
   - 目标：零个或多个目标名（无 `-` 前缀的参数）
3. 预处理 Makefile：`process_makefile(verbose, line_arr)`
   - 逐行读取 `./Makefile`，去注释、裁尾空白，写入内存数组
   - 总是回显到 stdout；当 `-v` 时，另写净化内容到 `./Minimake_cleared.mk`
4. 语法检查：`grammar_check(line_arr)`
   - 规则：第一段必须以目标行开始；命令行以制表符开头；变量定义行允许出现在任何位置；其它无效行报错
5. 解析与变量展开：`parse_makefile()`
   - 变量定义行：`NAME = VALUE` 先展开右值，再 `var_set()` 存储（覆盖同名）
   - 目标行与依赖、命令行：在存储前调用 `var_expand_into()` 展开
   - 依赖 token 做“二次切分”：展开后再按空白拆分为多个依赖项
   - 得到 `Target_block[]` 数组（目标名/依赖/命令）
6. 解析合法性检查：`parse_check()`
   - 重复目标：`has_duplicate_target()`
   - 依赖合法性：若依赖既不是另一个目标，也不是当前目录存在的文件，则报错（与 GNU make 不同，这里是强校验）
7. 导出变量到环境：`var_export_to_env()`（便于命令中通过 `$NAME` 使用）
8. 构建依赖图与环检测（用于打印/调试）：
   - `build_dep_graph()` 构图（边方向：dep -> target）
   - `topo_sort_graph()` 打印拓扑序并检测环；若有环，直接退出
9. 并行构建：`build_parallel(tb_arr, tb_count, jobs, target)`
   - 未指定目标时，以第一个目标为根；指定多个目标时逐个触发

备注：当前“并行调度”不直接使用 `DepGraph`，而是基于 `Target_block` 间依赖关系做就绪性判断与分批执行；依赖图主要用于可视化与环检测。

## 变量系统与展开

所在文件：`src/parse_var_replace.c`，头文件：`include/parse_var_replace.h`

- 存储结构：线性表 `VarEntry g_vars[MAX_VARS]`，覆盖同名（后定义生效）
- 接口
  - `var_set(name, value)`：设置/覆盖变量
  - `var_get(name, out, out_size)`：读取；若未定义则回退到 `getenv(name)`；再无则空串
  - `var_expand_into(src, dst, dst_size)`：对字符串进行递归展开（最大深度 16）
  - `var_export_to_env()`：将内部变量通过 `setenv` 导出为进程环境变量
- 语法与规则
  - 支持 `$(NAME)` 与 `${NAME}` 两种书写
  - 支持 `$$` 转义为单个 `$`
  - 未定义变量替换为空串（静默）
  - 变量右值在 `var_set` 前会先做一次展开（类似递归变量）

## Makefile 解析与结构

所在文件：`src/parse.c`，头文件：`include/parse.h`

- 数据结构 `Target_block`
  - `target`：目标名（已展开）
  - `dep_arr[]`：依赖列表（展开后并进行二次拆分）
  - `commands[]`：命令行（去行末换行、trim 并展开）
- 关键函数
  - `parse_target_line()`：提取 `target` 与原始依赖串，逐依赖 token 展开后再按空白拆分
  - `parse_cmd_line()`：展开命令字符串
  - `parse_makefile()`：遍历预处理后的行，拆为多个 `Target_block`
  - `parse_check()`：重复目标与依赖有效性检查

## 依赖图与拓扑排序

所在文件：`src/graph.c`，头文件：`include/graph.h`

- 图结构 `DepGraph`
  - 邻接矩阵 `adj[MAX_GRAPH_NODES][MAX_GRAPH_NODES]`，入度数组 `indegree[]`
  - 节点 `GraphNode { name, is_target }`，同名复用，若后续发现是目标会“升级” `is_target=1`
- 构图：`build_dep_graph()`
  - 先添加所有目标节点，再对每个目标添加依赖节点并连边 `dep -> target`，累加目标入度
- 拓扑序：`topo_sort_graph()`
  - Kahn 算法，打印拓扑序；若 `count != node_count` 则认为存在环并报错退出
- 子集收集（可按需构建扩展用）：`collect_needed_nodes()` 通过逆向 DFS 收集目标所需全部祖先节点

提示：当前构图仅用于打印与检测环，实际构建调度使用 `build_parallel()` 内部逻辑。

## 按需重建与并行执行

所在文件：`src/build.c`、`src/execute_cmd.c`，头文件：`include/build.h`、`include/execute_cmd.h`

- 是否需要重建：`target_need_build(tb_arr, i)`
  - 若目标文件不存在：要求所有依赖文件存在（否则报错返回 -1），并判定需要构建
  - 若目标存在：只要任一依赖的 `mtime > target.mtime`，则需要构建；否则视为 up-to-date
- 并行调度：`build_parallel(tb_arr, tb_count, jobs, root_target)`
  - 确定根：默认第一个目标；若传入 `target` 则以其为根
  - 计算“需要构建的子图”：`mark_needed_dfs()` 沿着“目标→其依赖的目标”来标记
  - 循环分批：
    1) 收集就绪目标（其依赖目标要么不在子图、要么已 built）
    2) 调用 `target_need_build()` 决定是否加入本批次；up-to-date 直接标记完成
    3) `execute_targets_parallel()` 将本批次目标并行执行
  - `jobs` 并发度：
    - 若命令行 `-j N`/`-jN` 指定则取 N
    - 否则自动取在线 CPU 核心数（`sysconf(_SC_NPROCESSORS_ONLN)`）
- 命令执行：
  - 单条命令：`/bin/sh -c "cmd"`，见 `run_single_command()`
  - 目标执行：`execute_target_commands()` 按序运行命令，任意一条非 0 退出则该目标失败
  - 批次并行：`execute_targets_parallel()` 为每个目标 fork 子进程，父进程等待并收集退出码
- 输出约定：
  - up-to-date：`[UP-TO-DATE] <target>`
  - 并行启动：`[PAR] start target: <target>`
  - 命令打印：`[CMD n] <command>`

## 预处理与语法检查

- 预处理：`src/preprocess.c`
  - `remove_comments()`：从首个 `#` 截断
  - `trim_trailing_whitespace()`：去尾部空白
  - `is_empty_line()`：判断是否全空白
  - `process_makefile()`：读取 `./Makefile`，写入内存并（总是）打印；当 `-v` 时，另行输出 `Minimake_cleared.mk`
- 语法检查：`src/grammar_check.c`
  - 行类型判定：目标行、命令行、变量行、注释、空行、无效行
  - 错误示例：
    - 规则前出现命令行（`Command found before rule`）
    - 目标定义缺少冒号（`Missing colon in target definition`）
    - 命令行未以制表符开头

## 支持的语法

已支持
- 目标规则：`target: deps...`；命令行以制表符开头
- 变量定义与展开：`NAME = VALUE`，`$(NAME)`/`${NAME}`，支持嵌套与 `$$ -> $`
- 环境变量：未在内部表找到时，`var_get` 回退到 `getenv`
- 并行执行：`-j N`（默认取在线 CPU 数）
- 按需重建：基于依赖与目标的修改时间（`stat`）

## 目录结构与关键常量

- 目录
  - `include/`：公共头文件
  - `src/`：模块实现
  - `test/`：示例/测试资源（含一个示例 `Makefile`、`app`、`libutil.*`）
  - `bin/`：最终可执行文件输出目录
- 常量（见 `include/common.h`）
  - 行/块/变量/图节点上限：`MAX_LINE_NUMBERS=1000`、`MAX_BLOCK_NUMBERS=100`、`MAX_VARS=256`、`MAX_GRAPH_NODES=512` 等

## 使用与调试

- 构建 minimake：使用 CMake（默认输出至 `bin/minimake`）
- 在项目根目录准备 `Makefile` 后运行 minimake：
  - 默认构建第一个目标；或指定多个目标名
  - 可加 `-j` 控制并发，`-v` 生成 `Minimake_cleared.mk` 便于排查解析问题
- 观察输出：
  - 预处理输出、依赖图与拓扑序（含环检测）、目标就绪与 up-to-date 信息、命令执行日志

## 典型边界与错误模式

- 变量递归过深：超过 16 层则停止继续展开（原样输出剩余文本）
- 目标缺失依赖：`target_need_build` 会报错并中断构建
- 环依赖：拓扑排序检测到环后退出
- 命令失败：任一命令非 0 退出会中断该目标（并行模式将停止继续启动新目标，等待已启动进程回收）

## 函数清单与注释（按模块）

以下按源码模块列出函数的用途、参数、返回值与注意事项。标注“内部”的为模块内静态函数。

### 程序入口（src/main.c）

- int main(int argc, char *argv[])
  - 用途：程序入口，串联变量初始化、参数解析、文件预处理、语法检查、解析、依赖图打印与环检、并行构建。
  - 参数：
    - argc/argv：命令行参数
  - 返回：0 成功；非 0 失败（解析失败、语法错误、依赖图或构建失败等）。
  - 注意：在失败路径上打印提示，并释放 `tb_arr`。

### 预处理（src/preprocess.c / include/preprocess.h）

- void trim_trailing_whitespace(char *str)
  - 用途：去除行尾空白字符（就地修改）。
  - 参数：str 输入/输出缓冲区。
  - 返回：无。

- void remove_comments(char *str)
  - 用途：删除从首个 `#` 起的注释（就地截断）。
  - 参数：str 输入/输出缓冲区。
  - 返回：无。

- int is_empty_line(const char *str)
  - 用途：判断是否仅包含空白。
  - 参数：str 字符串。
  - 返回：1 是空行；0 非空。

- int process_makefile(int verbose_mode, char line_arr[][MAX_LINE_LENGTH])
  - 用途：读取 `./Makefile`，去注释与尾空白，写入内存数组并打印；`-v` 时保存到 `Minimake_cleared.mk`。
  - 参数：verbose_mode 是否额外落盘；line_arr 输出二维行缓冲区。
  - 返回：0 正常；1 出错（文件打开/写出失败）。
  - 注意：总是向 stdout 打印每行（空行打印空串）。

### 语法检查（src/grammar_check.c / include/grammar_check.h）

- LineType line_type_judge(const char *str)
  - 用途：判定行类型（目标/命令/变量/注释/空/无效）。
  - 参数：str 行文本。
  - 返回：LineType 枚举。
  - 注意：变量行判定为“含 '=' 且等号左侧存在非空白”。

- int target_line_check(const char *str)
  - 用途：是否是目标行（首字符不是空白或冒号，且包含冒号）。
  - 参数：str 行文本。
  - 返回：1 是；0 否。

- int grammar_check(char line_arr[][MAX_LINE_LENGTH])
  - 用途：整体语法检查：首段必须以目标行开头；命令行以制表符；变量行允许任意处。
  - 返回：0 通过；1 存在错误（并打印行号与原因）。

### 变量系统与替换（src/parse_var_replace.c / include/parse_var_replace.h）

- void var_init(void)
  - 用途：清空内部变量表。

- int var_set(const char *name, const char *value)
  - 用途：设置/覆盖变量（后定义覆盖先定义）。
  - 参数：name 变量名；value 变量值（可为 NULL 视为空串）。
  - 返回：0 成功；-1 失败（name 为空或表已满）。

- int var_get(const char *name, char *out, size_t out_size)
  - 用途：读取变量到缓冲区；若内部无则回退 `getenv`；仍无则写入空串。
  - 参数：name 变量名；out 输出缓冲区；out_size 缓冲区大小。
  - 返回：写入长度（不含终止符）。

- void var_expand_into(const char *src, char *dst, size_t dst_size)
  - 用途：对 `src` 中的 `$(NAME)`/`${NAME}` 进行递归展开（最大深度 16），`$$` 展开为 `$`。
  - 返回：无（写入 `dst`）。

- void var_export_to_env(void)
  - 用途：将内部变量通过 `setenv` 导出到进程环境（覆盖同名）。

- 内部：static int find_var_index(const char *name)
  - 用途：在线性表中查找变量下标；不存在返回 -1。

- 内部：static void safe_append(char *dst, size_t dst_size, const char *src)
  - 用途：安全追加字符串到 `dst` 尾部，自动截断并保持 `\0` 结尾。

- 内部：static void safe_append_ch(char *dst, size_t dst_size, char ch)
  - 用途：安全追加单字符到 `dst` 尾部。

- 内部：static int expand_recursive(const char *src, char *dst, size_t dst_size, int depth)
  - 用途：变量展开的递归实现；`depth<=0` 时不再展开，原样输出。
  - 返回：0 成功；-1 参数错误。

### Makefile 解析（src/parse.c / include/parse.h）

- void trim(char *str)
  - 用途：去除首尾空白（就地修改）。

- void safe_copy(char *dst, size_t dst_size, const char *src)
  - 用途：安全拷贝字符串到固定大小缓冲区，保证以 `\0` 结尾。

- void parse_target_line(const char *str, Target_block *tb_arr, int tb_count)
  - 用途：解析目标行，展开目标名与依赖，并对依赖做“二次按空白切分”。
  - 参数：str 行文本；tb_arr 结果数组；tb_count 当前目标块下标。

- void parse_cmd_line(const char *str, Target_block *tb_arr, int tb_count, int cmd_count)
  - 用途：解析命令行，去尾部空白并展开变量后写入目标块命令数组。

- int parse_makefile(char line_arr[][MAX_LINE_LENGTH], Target_block *tb_arr)
  - 用途：遍历预处理结果，解析变量定义、目标与命令，组装多个 `Target_block`。
  - 返回：目标块数量 `tb_count`。
  - 注意：结束时会设置最后一个块的 `cmd_count` 并调用 `print_target_blocks` 进行调试输出。

- void print_target_blocks(Target_block *tb_arr, int tb_count)
  - 用途：调试打印目标块的目标名/依赖/命令。

- int has_duplicate_target(Target_block *tb_arr, int tb_count)
  - 用途：检测重复的目标定义。
  - 返回：1 存在重复；0 否。

- int is_dep_invaild(Target_block *tb_arr, int tb_count, const char *dep)
  - 用途：校验依赖是否有效（是其他目标或当前目录存在的文件其一）。
  - 返回：1 无效并打印提示；0 有效。

- int parse_check(Target_block *tb_arr, int tb_count)
  - 用途：组合进行重复目标与依赖有效性检查。
  - 返回：0 通过；1 存在错误。

### 依赖图（src/graph.c / include/graph.h）

- int graph_find_node(const DepGraph *g, const char *name)
  - 用途：按名称查找节点下标；未找到返回 -1。

- int build_dep_graph(DepGraph *g, Target_block *tb_arr, int tb_count)
  - 用途：构建依赖图（边：dep -> target），并计算入度。
  - 返回：0 成功；-1 节点超限等错误。

- int topo_sort_graph(const DepGraph *g, int order[], int *order_len)
  - 用途：Kahn 算法进行拓扑排序并打印结果。
  - 返回：0 成功；-1 检测到环。

- int collect_needed_nodes(const DepGraph *g, int target_index, int needed[])
  - 用途：基于逆向 DFS 收集 `target_index` 的所有传递性依赖与自身（标记到 needed[]）。
  - 返回：0 成功；-1 参数越界。

- void print_graph(const DepGraph *g)
  - 用途：打印节点列表与所有边（dep -> target）。

- 内部：static int add_node(DepGraph *g, const char *name, int is_target)
  - 用途：添加或复用节点；若同名已存在且本次为目标则升级 `is_target=1`。
  - 返回：节点下标；-1 超限。

- 内部：static void reverse_dfs(const DepGraph *g, int node_index, int needed[])
  - 用途：沿逆边（u -> node_index）递归标记可达节点。

### 构建调度与执行（src/build.c / include/build.h；src/execute_cmd.c / include/execute_cmd.h）

- int target_need_build(Target_block *tb_arr, int tb_index)
  - 用途：基于 mtime 判定目标是否需要重建。
  - 返回：1 需要；0 已最新；-1 缺失依赖或 `stat` 出错（并打印）。

- int build_parallel(Target_block *tb_arr, int tb_count, int jobs, const char *target)
  - 用途：以根目标为起点批次并行构建；自动挑选就绪目标并在每批内并行执行。
  - 返回：0 成功；1 失败（无效目标、执行失败等）。

- int execute_target_commands(Target_block *tb_arr, int tb_index)
  - 用途：顺序执行目标内命令，任一命令失败则中止该目标。
  - 返回：0 成功；-1 失败。

- int execute_targets_parallel(Target_block *tb_arr, const int *indices, int count, int max_parallel)
  - 用途：将一批就绪目标并行执行（为每个目标 fork 一次，子进程内顺序跑命令）。
  - 返回：0 全部成功；-1 其中任一失败或系统调用出错。

- 内部：static int find_target_index(Target_block *tb_arr, int tb_count, const char *name)
  - 用途：在线性表中按名称查找目标块下标；未找到返回 -1。

- 内部：static void mark_needed_dfs(Target_block *tb_arr, int tb_count, int idx, char *needed)
  - 用途：从根目标递归沿“目标依赖的目标”关系标记需要构建的子图。

- 内部：static int run_single_command(const char *cmd)
  - 用途：`/bin/sh -c` 执行单条命令；判定退出状态与信号终止。
  - 返回：0 成功；-1 失败。

- 内部：static int determine_max_jobs(int requested)
  - 用途：确定并发度；优先使用 `requested`，否则取在线 CPU 数，至少为 1。

### CLI 参数解析（src/clioptions_parse.c / include/clioptions_parse.h）

- void print_usage(const char *prog)
  - 用途：打印使用说明与示例。

- int parse_args(int argc, char **argv, CliOptions *out)
  - 用途：解析 `-h/--help`、`-v/--verbose_mode`、`-j N` 或 `-jN` 以及位置参数目标名。
  - 返回：0 成功；-1 非法选项或 `-j` 值非法。
  - 注意：未知选项（以 `-` 开头且不识别）会报错返回。



