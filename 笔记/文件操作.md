# 概述

- 在操作系统中，为了统一对各种硬件的操作，简化接口，不同的硬件设备也都被看成一个文件。对这些文件的操作，等同于对磁盘上普通文件的操作。例如，通常把显示器称为标准输出文件，printf 就是向这个文件输出，把键盘称为标准输入文件，scanf 就是从这个文件获取数据。
- 数据在文件和内存之间传递的过程叫做文件流。数据从文件复制到内存的过程叫做输入流，从内存保存到文件的过程叫做输出流。我们把数据在数据源和程序（内存）之间传递的过程叫做数据流(Data Stream)。相应的，数据从数据源到程序（内存）的过程叫做输入流(Input Stream)，从程序（内存）到数据源的过程叫做输出流(Output Stream)。
- 数据在内存中以`二进制`的形式存储，如果不加转换的输出，就是`二进制文件`，如果加以`ASCII`字符的形式转换，那存储的文件就是`文本文件`。
- `字符`使一律以`ASCII`形式存储【这也是为什么上述我们讲的二进制读取和文本读取字符的效果一样】，`数值型`数据既可以用`ASCII`形式存储，也可以使用`二进制`形式存储

# 文件的基本操作

## 打开与关闭

~~~c
// fopen() 函数用来打开一个文件，它的原型为：
FILE *fopen(char *filename, char *mode);
// fopen() 会获取文件信息，包括文件名、文件状态、当前读写位置等，并将这些信息保存到一个FILE类型的结构体变量中，然后将该变量的地址返回。

// 如果希望接收 fopen() 的返回值，就需要定义一个 FILE 类型的指针。例如：
FILE *fp = fopen("demo.txt", "r");
~~~

| 打开方式 | 说明                                                         |
| -------- | ------------------------------------------------------------ |
| r        | 只读。该文件必须存在。                                       |
| r+       | 以读/写方式打开文件。该文件必须存在。                        |
| rb+      | 以读/写方式打开一个二进制文件。该文件必须存在。              |
| rt+      | 以读/写方式打开一个文本文件。该文件必须存在。                |
| w        | 只写，若文件存在则长度清为0，即该文件内容消失，若不存在则创建该文件。 |
| w+       | 以读/写方式打开文件，若文件存在则文件长度清为零，即该文件内容会消失。若文件不存在则建立该文件。 |
| a        | 以追加的方式打开只写文件。若文件不存在，则会建立该文件，如果文件存在，写入的数据会被加到文件尾，即文件原先的内容会被保留（EOF符保留）。 |
| a+       | 以追加方式打开可读/写的文件。若文件不存在，则会建立该文件，如果文件存在，则写入的数据会被加到文件尾后，即文件原先的内容会被保留（原来的EOF符不保留）。 |
| wb       | 以只写方式打开或新建一个二进制文件，只允许写数据。           |
| wb+      | 以读/写方式打开或建立一个二进制文件，允许读和写。            |
| wt+      | 以读/写方式打开或建立一个文本文件，允许读写。                |
| at+      | 以读/写方式打开一个文本文件，允许读或在文本末追加数据。      |
| ab+      | 以读/写方式打开一个二进制文件，允许读或在文件末追加数据。    |

~~~C
// 打开一个文件时，如果出错，fopen将返回一个空指针值NULL
if( (fp=fopen("D:\\demo.txt","rb") == NULL ){
    printf("Error on open D:\\demo.txt file!");
    getch();
    exit(1);
}
~~~

~~~c
// 文件一旦使用完毕，应该用fclose()函数把文件关闭，以释放相关资源，避免数据丢失。fclose() 的原型为：
int fclose(FILE *fp);

// 文件正常关闭时，fclose() 的返回值为0，如果返回非零值则表示有错误发生。
~~~

~~~C
int main()
{
    //打开文件
    FILE* fp = fopen ("test.txt","w");

    //判断文件指针
    if (fp==NULL)
    {
        perror("fopen");
        return 1;
    }

    //文件使用
    //...

    //关闭文件
    fclose(fp);
    fp = NULL;

    return 0;
}
~~~

## 文件的顺序读写

| 功能           | 函数名  |
| -------------- | ------- |
| 字符输入函数   | fgetc   |
| 字符输出函数   | fputc   |
| 文本行输入函数 | fgets   |
| 文本行输出函数 | fputs   |
| 格式化读取函数 | fscanf  |
| 格式化写入函数 | fprintf |
| 二进制读       | fread   |
| 二进制写       | fwrite  |

~~~c
int fputc ( int character, FILE * stream );
int fgetc ( FILE * stream );	// 返回的是读取的字符的ASCII值，每次使用fgetc函数，读取文件中的一个字符后，文件指针会自动偏移一下，指向下一个字符，方便读取下一个字符
int fputs ( const char * str, FILE * stream );
char * fgets ( char * str, int num, FILE * stream );	// str为将从文件中读取的字符串，拷贝到str指向的空间中（一般为数组），num为读取字符串的个数，实际读取的字符个数的字符串会比num少一个（因为需要预留一个位置给函数放\0到str中）
int fprintf ( FILE * stream, const char * format, ... );
int fscanf ( FILE * stream, const char * format, ... );
~~~

~~~c
// fread：从文件流中读取 nmemb 个元素，每个元素 size 字节，存入 ptr 指向的内存。
// fwrite：将 ptr 指向的内存中 nmemb 个元素（每个 size 字节）写入文件流。
#include <stdio.h>
#include <string.h>

struct Student {
    char name[20];
    int age;
    float score;
};

int main() {
    struct Student s1 = {"Alice", 18, 95.5f};
    struct Student s2;

    // 写入二进制文件
    FILE *fp = fopen("student.dat", "wb");
    if (!fp) {
        perror("fopen write");
        return 1;
    }
    fwrite(&s1, sizeof(struct Student), 1, fp);
    fclose(fp);

    // 从文件读取
    fp = fopen("student.dat", "rb");
    if (!fp) {
        perror("fopen read");
        return 1;
    }
    fread(&s2, sizeof(struct Student), 1, fp);
    fclose(fp);

    printf("Name: %s\nAge: %d\nScore: %.1f\n", s2.name, s2.age, s2.score);
    return 0;
}
~~~

~~~c
int sprintf(char *str, const char *format, ...);	// 返回写入的字符数（不包括结尾的 \0）。
int sscanf(const char *str, const char *format, ...);	// 返回成功匹配并赋值的参数个数，如果匹配失败，返回值会小于预期。

#include <stdio.h>

int main() {
    char buffer[100];
    int age = 25;
    float score = 89.5f;
    char name[] = "Alice";

    // 格式化写入字符串
    int n = sprintf(buffer, "Name: %s, Age: %d, Score: %.1f", name, age, score);

    printf("Formatted string: %s\n", buffer);
    printf("Characters written: %d\n", n); // 不包括 '\0'
	
    char input[] = "Alice 25 89.5";
    char name[20];
    int age;
    float score;

    // 从字符串中解析数据
    int n = sscanf(input, "%s %d %f", name, &age, &score);

    printf("Name: %s\nAge: %d\nScore: %.1f\n", name, age, score);
    printf("Items successfully parsed: %d\n", n);

    return 0;
}
~~~

~~~C
int fseek ( FILE * stream, long int offset, int origin );
// offset为文件指针的偏移量，origin为文件指针偏移量的相对起始地址
// SEEK_SET：“文件的起始位置处” 开始偏移
// SEEK_CUR：“当前文件指针的位置” 开始偏移
// SEEk_END：“文件末尾处” 开始偏移

long int ftell ( FILE * stream );
// 返回文件指针相对于起始位置的偏移量

void rewind ( FILE * stream );
// 让文件指针的位置回到文件的起始位置
~~~

# 文件读取结束的判定

~~~C
int feof ( FILE * stream );	// 若文件结束时因为遇到文件尾结束的，则返回非0值；若文件结束不是因为遇到文件尾结束的，则返回0

// feof只能判断是哪种原因结束的，但不能用来判断文件是否结束
// 文件读取是否结束，我们根据如下来判断：
// 文本文件：
// fgetc在读取结束时，返回EOF
// fgets在读取结束时，返回NULL
// 二进制文件：
// fread在读取结束时，返回一个小于实际要读的个数的值
~~~

# 缓冲区

## 概念

-  **文件缓冲区** 是一块内存区域，用于暂存从文件读取的数据，或暂存要写入文件的数据，以减少对磁盘或设备的频繁访问，提高 I/O 效率。 当你使用 `fopen()` 打开文件时，系统会自动为该文件流（`FILE*`）分配一个缓冲区。

| 类型         | 说明                         | 典型应用场景       |
|--------------|------------------------------|--------------------|
| **全缓冲** | 数据填满缓冲区后才进行实际 I/O | 普通磁盘文件（默认） |
| **行缓冲** | 遇到换行符 `\n` 或缓冲区满时刷新 | `stdout`（终端输出） |
| **无缓冲** | 每次 I/O 立即执行，不缓存     | `stderr`（错误输出） |

## 缓冲区刷新

- 数据从缓冲区真正写入文件/设备，称为“刷新”。触发刷新的条件包括：

✅ **自动刷新：**

- 缓冲区满（全缓冲）
- 遇到换行符 `\n`（行缓冲）
- 调用 `fclose()` 关闭文件
- 程序正常结束（`main` 返回或 `exit()`）
- 输入操作前（如 `scanf` 前会刷新 `stdout`）

✅ **手动刷新：**

- `fflush(FILE *stream);  // 强制刷新指定流的缓冲区`

- `fflush(stdin)` 清空输入缓冲区” → 标准未定义，行为不可靠！（应使用 `while(getchar() != '\n');`
