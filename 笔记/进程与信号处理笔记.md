# fork( )

## 基本概念
~~~C
// 函数原型：

pid_t fork(void)；//pid_t为int类型，进行了重载
pid_t getpid();   // 获取当前进程的 pid 值。
pid_t getppid();  //获取当前进程的父进程 pid 值。

// 在父进程中，fork返回新创建子进程的进程ID；
// 在子进程中，fork返回0；
// 如果出现错误，fork返回一个负值。
~~~

- 进程形成了链表，父进程的fpid(p 意味point)指向子进程的进程id, 因为子进程没有子进程，所以其fpid为0
- *ppid指当前进程的父进程pid* 
- *pid指当前进程的pid* 
- *fpid指fork返回给当前进程的值*

## fork()的执行过程

>申请PID
申请PCB结构
复制父进程的PCB
将子进程的运行状态设置为不可执行的
将子进程中的某些属性清零，某些保留，某些修改
复制父进程的页（用到了写时拷贝技术）

- 写实拷贝技术： 父子进程在初始阶段共享所有的数据（全局、 栈区、 堆区、 代码）， 内核会将所有的区域设置为只读。 当父子进程中任意一个进程试图修改其中的数据时， 内核才会将要修改的数据所在的区域（页） 拷贝一份。

# execvp()

- 用 exec 函数可以把当前进程替换为一个新进程，执行一个新的程序，且新进程与原进程有相同的 PID

~~~C
int execvp(const char *file, char *const argv[]);
~~~

- 用于用新进程映像替换当前进程映像
- 只有当 `file` 参数中不包含斜杠 `/` 时，`execvp()` 才会在环境变量 `PATH` 中列出的目录里搜索该可执行文件。如果 `file` 中包含 `/`（哪怕只是一个，比如 `/bin/sh`、`./myprog`、`/usr/bin/ls`），则 `execvp()` 会将其视为“绝对路径”或“相对路径”，直接尝试执行该路径下的文件，而不会去搜索 `PATH`。 
- arg 参数表示启动程序所带的参数，一般第一个参数为要执行命令名， arg 必须以NULL 结尾。
- 返回值：成功时不返回，同一代码路径上的后续语句永远不会执行；失败返回 -1并设置errno。

# wait和waitpid

## wait()

~~~c
#include <sys/types.h> /* 提供类型pid_t的定义 */
#include <sys/wait.h>
pid_t wait(int *status)
~~~

1. 进程一旦调用了wait，就立即阻塞自己，由wait自动分析是否当前进程的某个子进程已经退出，如果让它找到了这样一个已经变成僵尸的子进程，wait就会收集这个子进程的信息，并把它彻底销毁后返回；如果没有找到这样一个子进程，wait就会一直阻塞在这里，直到有一个出现为止。

2. 参数status用来保存被收集进程退出时的一些状态，它是一个指向int类型的指针。但如果我们对这个子进程是如何死掉的毫不在意，只想把这个僵尸进程消灭掉，（事实上绝大多数情况下，我们都会这样想），我们就可以设定这个参数为NULL，就象这样：`pid = wait(NULL);`

3. 如果成功，wait会返回被收集的子进程的进程ID，如果调用进程没有子进程，调用就会失败，此时wait返回-1，同时errno被置为ECHILD。

~~~C
// wait调用例程：

/* wait1.c */
#include <sys/types.h>
#include <sys/wait.h>
#include <unistd.h>
#include <stdlib.h>

main()
{
    pid_t pc,pr;    
    pc=fork();

    if(pc<0) 
        printf("error ocurred!/n");
    else if(pc==0){ /* 如果是子进程 */
        printf("This is child process with pid of %d/n",getpid());
        sleep(10); /* 睡眠10秒钟 */
    }
    else{ /* 如果是父进程 */
        pr=wait(NULL); /* 在这里等待 */
        printf("I catched a child process with pid of %d/n"),pr);
    }
    exit(0);
}

// 运行结果
This is child process with pid of 1508
I catched a child process with pid of 1508
~~~

> 只有子进程从睡眠中苏醒过来，它才能正常退出，也就才能被父进程捕捉到。这里不管设定子进程睡眠的时间有多长，父进程都会一直等待下去。

4. 参数status：如果参数status的值不是NULL，wait就会把子进程退出时的状态取出并存入其中，这是一个整数值（int）。

5. 
- `WIFEXITED(status) `这个宏用来指出子进程是否为正常退出的，如果是，它会返回一个非零值（请注意，虽然名字一样，这里的参数status并不同于wait唯一的参数---指向整数的指针status，而是那个指针所指向的整数）；0 表示非正常退出（如被信号杀死）。

- `WEXITSTATUS(status)`
  作用：提取子进程的退出码（``exit code`）。
  退出码范围是 0 ~ 255（只取低 8 位）。
  按惯例：0 表示成功；非 0 表示失败（具体含义由程序定义）。
  仅在 `WIFEXITED(status)` 为真时有效！

- `WIFSIGNALED(status)`
  作用：判断子进程是否被信号异常终止（如 SIGKILL、SIGSEGV）。
  返回值：非零表示被信号杀死。
  
-  `WTERMSIG(status)`
  作用：获取导致子进程终止的信号编号（如 `9` 表示 `SIGKILL`，`11` 表示 `SIGSEGV`）。
  仅在 `WIFSIGNALED(status)` 为真时有效！


~~~C
/* wait2.c */
#include <sys/types.h>
#include <sys/wait.h>
#include <unistd.h>

main()
{
    int status;
    pid_t pc,pr;
    
    pc=fork();

    if(pc<0) /* 如果出错 */
        printf("error ocurred!/n");
    else if(pc==0){ /* 子进程 */
        printf("This is child process with pid of %d./n",getpid());
        exit(3); /* 子进程返回3 */
    }
    else{ /* 父进程 */
        pr=wait(&status);

        if(WIFEXITED(status)){ /* 如果WIFEXITED返回非零值 */
            printf("the child process %d exit normally./n",pr);
            printf("the return code is %d./n",WEXITSTATUS(status));
        }else /* 如果WIFEXITED返回零 */
            printf("the child process %d exit abnormally./n",pr);
    }
}

// 运行结果
This is child process with pid of 1538.
the child process 1538 exit normally.
the return code is 3.
~~~

> 父进程准确捕捉到了子进程的返回值3，并把它打印了出来。

5. 进程同步：有时候，父进程要求子进程的运算结果进行下一步的运算，或者子进程的功能是为父进程提供了下一步执行的先决条件（如：子进程建立文件，而父进程写入数据），此时父进程就必须在某一个位置停下来，等待子进程运行结束，而如果父进程不等待而直接执行下去的话，可以想见，会出现极大的混乱。这种情况称为进程之间的同步，更准确地说，这是进程同步的一种特例。**进程同步就是要协调好2个以上的进程，使之以安排好地次序依次执行**。下面是解决进程同步的一个例子：

~~~c
#include <sys/types.h>
#include <sys/wait.h>

main()
{
    pid_t pc, pr;
    int status;

    pc=fork();

    if(pc<0)
    	printf("Error occured on forking./n");
    else if(pc==0){	/* 子进程的工作 */
        exit(0);
    }else{	    /* 父进程的工作 */
        pr=wait(&status);
    	/* 利用子进程的结果 */
        ...
    }
}
~~~

> 首先，当fork调用成功后，父子进程各做各的事情，但当父进程的工作告一段落，需要用到子进程的结果时，它就停下来调用wait，一直等到子进程运行结束，然后利用子进程的结果继续执行。

## waitpid()

~~~C
// waitpid系统调用在Linux函数库中的原型是：
#include <sys/types.h> /* 提供类型pid_t的定义 */
#include <sys/wait.h>
pid_t waitpid(pid_t pid,int *status,int options)
~~~

- 从本质上讲，系统调用waitpid和wait的作用是完全相同的，但waitpid多出了两个可由用户控制的参数pid和options，从而为我们编程提供了另一种更灵活的方式。

- pid：从参数的名字pid和类型pid_t中就可以看出，这里需要的是一个进程ID。但当pid取不同的值时，在这里有不同的意义。

### 参数

```te
     pid>0时，只等待进程ID等于pid的子进程，不管其它已经有多少子进程运行结束退出了，只要指定的子进程还没有结束，waitpid就会一直等下去。
     pid=-1时，等待任何一个子进程退出，没有任何限制，此时waitpid和wait的作用一模一样。
     pid=0时，等待同一个进程组中的任何子进程，如果子进程已经加入了别的进程组，waitpid不会对它做任何理睬。
     pid<-1时，等待一个指定进程组中的任何子进程，这个进程组的ID等于pid的绝对值。
```

- options：options提供了一些额外的选项来控制waitpid，目前在Linux中只支持`WNOHANG和WUNTRACED`两个选项，这是两个常数，可以用"|"运算符把它们连接起来使用，比如：`ret=waitpid(-1,NULL,WNOHANG | WUNTRACED);如果我们不想使用它们，也可以把options设为0，如：ret=waitpid(-1,NULL,0);`
- 如果使用了WNOHANG参数调用waitpid，即使没有子进程退出，它也会立即返回，不会像wait那样永远等下去。

### 返回值和错误

waitpid的返回值比wait稍微复杂一些，一共有3种情况：

    当正常返回的时候，waitpid返回收集到的子进程的进程ID；
    如果设置了选项WNOHANG，而调用中waitpid发现没有已退出的子进程可收集，则返回0；
    如果调用中出错，则返回-1，这时errno会被设置成相应的值以指示错误所在；

- 当pid所指示的子进程不存在，或此进程存在，但不是调用进程的子进程，waitpid就会出错返回，这时errno被设置为ECHILD；

~~~C
/* waitpid.c */
#include <sys/types.h>
#include <sys/wait.h>
#include <unistd.h>

main()
{
    pid_t pc, pr;
    pc=fork();

    if(pc<0) /* 如果fork出错 */
        printf("Error occured on forking./n");
    else if(pc==0){ /* 如果是子进程 */
        sleep(10); /* 睡眠10秒 */
        exit(0);
    }
    /* 如果是父进程 */
    do{
       	 pr=waitpid(pc, NULL, WNOHANG); /* 使用了WNOHANG参数，waitpid不会在这里等待 */
        if(pr==0){ /* 如果没有收集到子进程 */
            printf("No child exited/n");
            sleep(1);
        }
    }while(pr==0); /* 没有收集到子进程，就回去继续尝试 */
    
    if(pr==pc)
        printf("successfully get child %d/n", pr);
    else
        printf("some error occured/n");
}

No child exited
No child exited
No child exited
No child exited
No child exited
No child exited
No child exited
No child exited
No child exited
No child exited
successfully get child 1526
~~~

